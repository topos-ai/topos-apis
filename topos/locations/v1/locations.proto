syntax = "proto3";

package topos.locations.v1;

import "google/api/annotations.proto";

option go_package = "topos/locations/v1;locations";

service Locations {
  // Gets a region.
  rpc GetRegion(GetRegionRequest) returns (Region) {
    option (google.api.http) = {
      get : "/v1/{name=regionTypes/*/regions/*}"
    };
  }

  // Gets a region geometry.
  rpc GetRegionGeometry(GetRegionGeometryRequest)
      returns (stream GetRegionGeometryResponse) {
    option (google.api.http) = {
      get : "/v1/{name=regionTypes/*/regions/*}/geometry"
    };
  }

  // Sets a region.
  rpc SetRegion(SetRegionRequest) returns (Region) {
    option (google.api.http) = {
      post : "/v1/{region.name=regionTypes/*/regions/*}"
      body : "region"
    };
  }

  // Sets a region.
  rpc SetRegionGeometry(stream SetRegionGeometryRequest)
      returns (SetRegionGeometryResponse) {
    option (google.api.http) = {
      post : "/v1/{name=regionTypes/*/regions/*}/geometry"
      body : "*"
    };
  }

  // Region feature values by feature.
  rpc GetRegionFeatureSetValues(GetRegionFeatureSetValuesRequest)
      returns (GetRegionFeatureSetValuesResponse) {
    option (google.api.http) = {
      get : "/v1/{region=regionTypes/*/regions/*}/{feature_set=featureSets/*}/"
            "values"
    };
  }

  // Search regions.
  rpc SearchRegions(SearchRegionsRequest) returns (SearchRegionsResponse) {
    option (google.api.http) = {
      post : "/v1/{region_type=regionTypes/*}/regions:search"
    };
  }

  // Locate regions.
  rpc LocateRegions(LocateRegionsRequest) returns (LocateRegionsResponse) {
    option (google.api.http) = {
      post : "/v1/{region_type=regionTypes/*}/regions:locate"
    };
  }

  // Intersect regions.
  rpc IntersectRegions(stream IntersectRegionsRequest)
      returns (IntersectRegionsResponse) {
    option (google.api.http) = {
      post : "/v1/{region_type=regionTypes/*}/regions:intersect"
      body : "*"
    };
  }
}

enum GeometryEncoding {
  S2 = 0;
  GEOJSON = 1;
}

message RegionType {
  // The name of the region type. It must have the format
  // `"regionTypes/{region_type}"`. `{region_type}` must match the [regular
  // expression](https://github.com/google/re2/wiki/Syntax)
  // `^[a-z\d]+(-[a-z\d]+)*$`
  string name = 1;
}

message Region {
  // The name of the region. It must have the format
  // `"regionTypes/{region_type}/regions/{region}"`.
  // `{region}` must match the [regular
  // expression](https://github.com/google/re2/wiki/Syntax)
  // `^[a-z\d]+(-[a-z\d]+)*$`
  string name = 1;

  // A property value.
  message Property {
    oneof value {
      string String = 1;
      double Number = 2;
    }
  }

  // The region properties.
  map<string, Property> properties = 3;
}

message GetRegionRequest { string name = 1; }

message GetRegionGeometryRequest { string name = 1; }

message GetRegionGeometryResponse { bytes polygon_chunk = 1; }

message SetRegionRequest { Region region = 1; }

message SetRegionGeometryRequest {
  // The region name.
  string name = 1;

  // The geometry data's encoding.
  GeometryEncoding geometry_encoding = 14;

  // A chunk of bytes of the encoded geometry.
  bytes geometry_chunk = 15;
}

message SetRegionGeometryResponse {}

message SearchRegionsRequest {
  // The maximum number of items to return.
  int32 page_size = 1;

  // The next_page_token value returned from a previous Search request, if any.
  string page_token = 2;

  // Return regions of the given type.
  string region_type = 3;

  // Return regions that intersect the given WKB-encoded geometry.
  bytes intersecting_geometry = 4;

  // Do not include region geometries in the response.
  bool exclude_geometry = 5;

  // Return regions included by the given region.
  string included_by_region = 6;
}

message SearchRegionsResponse {
  repeated Region regions = 1;

  // Token to retrieve the next page of results, or empty if there are no more
  // results in the search.
  string next_page_token = 2;
}

message GetRegionFeatureSetValuesRequest {
  string region = 1;
  string feature_set = 2;
}

message GetRegionFeatureSetValuesResponse {
  map<string, double> feature_values = 1;
}

message LatLng {
  double latitude = 1;
  double longitude = 2;
}

message LocateRegionsRequest {
  // Return regions of the given type.
  string region_type = 1;

  // Return region names that include the given location.
  LatLng location = 2;
}

message LocateRegionsResponse {
  // The located region names.
  repeated string regions = 1;
}

message IntersectRegionsRequest {
  // Return regions of the given type.
  string region_type = 1;

  // The geometry encoding.
  GeometryEncoding geometry_encoding = 14;

  // A chunk of the intersecting geometry.
  bytes geometry_chunk = 15;
}

message IntersectRegionsResponse {
  message IntersectingRegions {
    // The intersecting region name.
    string name = 1;

    // The percentage of the region's area included in the intersection.
    double region_area = 2;

    // The percentage of the intersection's area included in the region.
    double intersection_area = 3;
  }

  repeated IntersectingRegions intersecting_regions = 1;
}
